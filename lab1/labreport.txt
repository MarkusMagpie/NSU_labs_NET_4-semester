Вопросы: 
1 Зачем нужен маршрутизатор в сети?
    Маршрутизатор - устройство, которое отвечает за маршрутизацию. Он определяет оптимальный путь данных при перемещении из источника в место назначения.
    Находится на 3 уровне OSI - сетевом.

2 Чем маршрутизатор отличается от коммутатора? На каком уровне модели OSI они работают?
    Коммутатор — устройство для соединения нескольких узлов компьютерной сети в пределах одного или нескольких сегментов сети.

    Отличия: 
        1 Работают на разных уровнях: маршрутизатор на сетевом и работает с маршрутизацией пакетов, 
            а коммутатор на канальном
        2 маршрутизатор и коммутатор выполняют разные роли в сети: 
            первый обеспечивает связь между разными сетями, 
            а второй — эффективное взаимодействие устройств внутри одной локальной сети.

          (маршрутизаторы соединяют сети, а коммутаторы соединяют устройства внутри сети) 
    https://indikotrade.ru/news/press-reliz/marshrutizator-i-kommutator-v-chem-raznitsa/#:~:text=Наиболее%20существенное%20различие%20между%20маршрутизаторами,как%20коммутаторы%20подключают%20локальные%20устройства.

3 Что такое MAC-адрес и IP-адрес? В чём их отличие и для чего они используются?
    MAC-адрес (Media Access Control) 
        служит для идентификации сетевых интерфейсов узлов сети. 
        Используется на канальном уровне.
        Назначается либо централизованно - производителем оборудования, либо локально администратором сети

    IP-адрес (Internet Protocol) 
        адрес, присваемый хостам в сети для идентификации хоста. 
        Используется на сетевом уровне.
        Назначается и изменяется в зависимости от сетевой конфигурации. Можно изменить сделав вкл/выкл модема или маршрутизатора.

4 Может ли интернет или передача сообщений между компьютерами работать без маршрутизатора? Обоснуйте ответ.
    Обмен данными между компьютерами без маршрутизатора
        1) можно соединить 2 компьютера напрямую сетевым кабелем Ethernet
        2) peer-to-peer соединение (прикладной уровень, а маршрутизатор сетевой (?))
        3) коммутатор канального уровня - он же распределяет данные между узлами сети (и устройствами)

    Подключение к интернету:
        Напрямую подключить устройство к Интернету через кабель. Преимущество - стабильное соединение, но нельзя создать LAN!

    https://msk.t2.ru/journal/article/how-to-connect-to-the-internet-via-cable

Практика:
1 ClientComputer.cpp
    Задайте MAC-адрес и IP-адрес для каждого клиента
    Программа должна уметь отправлять ping-запросы другим узлам в сети.

    https://thecode.media/socket/#:~:text=Сокет%20—%20это%20виртуальная%20конструкция%20из,даже%20в%20пределах%20одного%20компьютера.

    how to check listening ports? https://www.cyberciti.biz/faq/unix-linux-check-if-port-is-in-use-command/ 
    для поиска нужных портов - sudo lsof -i -P -n | grep LISTEN 

    1) инициализация клиента: 
        стартуем с заданными параметрами IP-адрес и MAC-адрес клиента

    2) создаем UDP-сокет (create_udp_socket):
        создаем для обмена данными. Протокол: IPv4; Тип сокета: UDP. 
        + настроил таймаут 

    3) далее основной цикл - бесконечный до команды exit():
        а) жду ввода IP адреса на который нужно отправить ping
        б) формируем адрес получателя (create_destination_address(dest_ip))
            создается структура sockaddr_in для целевого узла
            inet_pton() - IP-адрес преобразуется из строки в бинарный формат
        в) отправка ping-сообщения (send_ping())
            https://ru.manpages.org/sendto/2 
        г) ждем ответа (receive_response()) - ждем ответа несколько секнд, если получил, то вывожу, иначе - таймаут сообщение

    для наглядности покажи nc -ulv 5000
        программа отправляет UDP-сообщения на порт 5000. Если на этом порту не запущен сервер, клиент не получит ответа и будет таймаут.
        nc -ul 5000 эмулирует простейший UDP-сервер, который принимает сообщения от клиента.
    могу получить сообщение что already in use. Тогда: sudo lsof -i :5000 - чтобы посмотреть какой процесс занимает порт и sudo kill -9 20834(порт) чтобы убить

    пример вывода: 
        sorokinm@sorokinm-CREFG-XX:~$ nc -ulv 5000
        Bound on 0.0.0.0 5000
        Connection received on localhost 35109
        PING 0 from 0.0.0.0 (AA:BB:CC:DD:EE:FF)

        то есть клиент реально отправил udp сообщение на порт 5000
        клиент с IP-адресом 0.0.0.0 и портом 35109 отправляет запрос на сервер

        Клиент (программа)	                    Сервер (netcat)
        1. Отправляет запрос с порта 35109 	->  Принимает запрос на порту 5000
        2. Ждет ответ на порту 35109        <-  Отправляет ответ на 0.0.0.0:35109

    client_ip - для других узлов, чтобы понимание от кого пришел запрос. Маршрутизатор сохранит его в таблице и держит там минуту
    dest_ip - ip-адрес маршрутизатора - куда клиент отправляет запрос
    target_ip - адрес узла - получателя, которому предназначен ping запрос. Маршрутизатор будет искать этот ip в таблице клиентов и если он там есть, 
        то пакет будет перенаправлен 

2 Router.cpp
    1) clean_clients()
    каждые 60 секунд проверяем активность клиентов и удаляем если ее нет

    2) parse_mac()
    извлекаю MAC адрес из соощения 

    3) handle_packet() - обработка входящих пакетов
        извлекаем IP и MAC отправителя
        обновляем таблицу клиентов 
        извлекает целевой IP (target_ip) из сообщения
        ищет целевой IP в таблице клиентов (сравнение client_ip и target_ip)
        перенаправляем пакет (sendto), если клиент найден, или сообщаем о недоступности

    4) run_router() - это основной цикл 
        здесь запущен фоновый поток для очистки неактивных клиентов (clean_clients)
        в бесконечном цикле принимаем udp-пакеты 
        для каждого пакета создает отдельный поток (handle_packet).

    Пример: 
    Пишем в sudo wireshark в localhost интерфейсе: udp.port == 5000
    Создаю 2 консоли 
    В 1 консоли пишу: 
        g++ -o router Router.cpp -pthread && ./router
    Во 2 консоли пишу: 
        g++ -o client1 Client1.cpp && ./client1
        вписываю 127.0.0.1 и 127.0.0.1
    Захожу в wireshark и показываю переход пакетов

